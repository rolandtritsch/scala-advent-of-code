"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3431],{1730:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var i=n(7462),a=(n(7294),n(3905));n(6340);const r={},o="Day 16: Reindeer Maze",s={unversionedId:"2024/puzzles/day16",id:"2024/puzzles/day16",title:"Day 16: Reindeer Maze",description:"by @merlinorg",source:"@site/target/mdoc/2024/puzzles/day16.md",sourceDirName:"2024/puzzles",slug:"/2024/puzzles/day16",permalink:"/scala-advent-of-code/2024/puzzles/day16",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2024/puzzles/day16.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 15: Warehouse Woes",permalink:"/scala-advent-of-code/2024/puzzles/day15"},next:{title:"Day 17: Chronospatial Computer",permalink:"/scala-advent-of-code/2024/puzzles/day17"}},l={},u=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution summary",id:"solution-summary",level:2},{value:"Data model",id:"data-model",level:3},{value:"Signum",id:"signum",level:4},{value:"Direction",id:"direction",level:4},{value:"Position",id:"position",level:4},{value:"Maze",id:"maze",level:4},{value:"Priority Queue",id:"priority-queue",level:3},{value:"Reindeer",id:"reindeer",level:4},{value:"Part 1",id:"part-1",level:2},{value:"Part 2",id:"part-2",level:2},{value:"Final Code",id:"final-code",level:2},{value:"Mutable solution",id:"mutable-solution",level:3},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],d={toc:u};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"day-16-reindeer-maze"},"Day 16: Reindeer Maze"),(0,a.kt)("p",null,"by ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/merlinorg"},"@merlinorg")),(0,a.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://adventofcode.com/2024/day/16"},"https://adventofcode.com/2024/day/16")),(0,a.kt)("h2",{id:"solution-summary"},"Solution summary"),(0,a.kt)("p",null,"Any time you see a puzzle like this, where you are searching for the\nlowest-cost route to a goal, you will pretty much immediately reach for\n",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"},"Dijkstra's algorithm"),"\nor one of its variants.  This algorithm maintains a priority queue of\nlocations being visited and  iteratively dequeues the current head location,\nenqueueing all of its  reachable neighbours that have not yet been reached by\na prior better path,  until a goal is met. The priority queue ensures that\nthe head location is always the current shortest path."),(0,a.kt)("p",null,"The wrinkle with this puzzle is that there is a cost both to move and to\nturn, so it is not enough to maintain a queue of locations and the cost to\nreach them; instead, you need a queue of locations with directions, and thus\nthe cost to reach a given location facing in a particular direction. Also,\nbecause our cost to move is always 1, we can simplify the visited neighbour\ncheck."),(0,a.kt)("p",null,"The resulting algorithm is as follows:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Parse the map, identifying the start, the end, and the walls."),(0,a.kt)("li",{parentName:"ol"},"Create a priority queue with the starting location, direction and cost,\nand a set of visited location and directions."),(0,a.kt)("li",{parentName:"ol"},"Iterate Dijkstra's algorithm until the end is reached.")),(0,a.kt)("h3",{id:"data-model"},"Data model"),(0,a.kt)("p",null,"First, we need to define some helper classes. Typical Advent of Coders\nmaintain simple libraries that provide all of these helpers."),(0,a.kt)("h4",{id:"signum"},"Signum"),(0,a.kt)("p",null,"We'll start with a simple ",(0,a.kt)("inlineCode",{parentName:"p"},"Signum")," data type that allows us to encode -1, 0 and 1."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"type Signum = -1 | 0 | 1\n\nextension (signum: Signum)\n  def reverse: Signum = if signum == 1 then -1 else if signum == -1 then 1 else 0\n")),(0,a.kt)("h4",{id:"direction"},"Direction"),(0,a.kt)("p",null,"With this, we can build a simple ",(0,a.kt)("inlineCode",{parentName:"p"},"Direction")," which is a ",(0,a.kt)("em",{parentName:"p"},"dx")," and ",(0,a.kt)("em",{parentName:"p"},"dy")," tuple. If\nyou are facing east, ",(0,a.kt)("em",{parentName:"p"},"dx")," is 1 and ",(0,a.kt)("em",{parentName:"p"},"dy")," is 0. If you are facing north, ",(0,a.kt)("em",{parentName:"p"},"dx")," is 0\nand ",(0,a.kt)("em",{parentName:"p"},"dy")," is -1. The ",(0,a.kt)("inlineCode",{parentName:"p"},"cw")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ccw")," extensions allow us to rotate a direction clockwise\nand counter-clockwise."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"type Direction = (Signum, Signum)\n\nval East: Direction = (1, 0)\n\nextension (direction: Direction)\n  def cw: Direction  = (direction(1).reverse, direction(0))\n  def ccw: Direction = (direction(1), direction(0).reverse)\n")),(0,a.kt)("h4",{id:"position"},"Position"),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"Position")," is an ",(0,a.kt)("em",{parentName:"p"},"x")," and ",(0,a.kt)("em",{parentName:"p"},"y")," tuple. You can add a direction to a position\nto arrive at a new position."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"type Position = (Int, Int)\n\nextension (position: Position)\n  def +(direction: Direction): Position = (position(0) + direction(0), position(1) + direction(1))\n")),(0,a.kt)("h4",{id:"maze"},"Maze"),(0,a.kt)("p",null,"We encode the ",(0,a.kt)("inlineCode",{parentName:"p"},"Maze")," simply as an array of strings, the first string being\nthe topmost row of the maze. We provide two extension methods: ",(0,a.kt)("inlineCode",{parentName:"p"},"findPosition"),"\nfinds the first position of a given character in the maze, and ",(0,a.kt)("inlineCode",{parentName:"p"},"apply")," allows\nus to interrogate the character at a given position."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"type Maze = Array[String]\n\nextension (maze: Maze)\n  def findPosition(char: Char): Option[Position] =\n    maze.zipWithIndex.collectFirst:\n      case (row, y) if row.contains(char) => row.indexOf(char) -> y\n\n  def apply(position: Position): Char = maze(position(1))(position(0))\n")),(0,a.kt)("h3",{id:"priority-queue"},"Priority Queue"),(0,a.kt)("p",null,"Scala 3 provides a convenient and performant ",(0,a.kt)("inlineCode",{parentName:"p"},"mutable.PriorityQueue"),". However,\nwe have principles on which we stand, one of which is to abjure ",(0,a.kt)("inlineCode",{parentName:"p"},"mutable"),", even\nat the cost of legibility and performance. So we will have to choose an immutable\nalternative."),(0,a.kt)("p",null,"It is possible to use ",(0,a.kt)("inlineCode",{parentName:"p"},"TreeSet")," as a priority queue, but sets exclude\nduplicates so it would be necessary to define a unique ordering over our values.\nWe only want to order by priority, with multiple same-priority values being allowed.\nSo instead we will adopt ",(0,a.kt)("inlineCode",{parentName:"p"},"TreeMap")," as our data structure: The keys in the tree\nwill be the priorities, the values a vector of the nodes with that priority (so,\nin effect a multi-value map)."),(0,a.kt)("p",null,"Our ",(0,a.kt)("inlineCode",{parentName:"p"},"PriorityQueue")," is a bit clunky, parameterized by both the key type (priority)\nand the value. Also, it cannot meekly enforce just ",(0,a.kt)("inlineCode",{parentName:"p"},"Ordering")," on the value type,\nwe need a ",(0,a.kt)("inlineCode",{parentName:"p"},"Priority")," typeclass that lets us extract order priority from each\nvalue. The ",(0,a.kt)("inlineCode",{parentName:"p"},"apply")," method allows us to construct a ",(0,a.kt)("inlineCode",{parentName:"p"},"PriorityQueue")," from a single\nvalue."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"type PriorityQueue[K, V] = TreeMap[K, Vector[V]]\n\ntrait Priority[K, V]:\n  def priority(value: V): K\n\nobject PriorityQueue:\n  def apply[K: Ordering, V](value: V)(using P: Priority[K, V]): PriorityQueue[K, V] =\n    TreeMap(P.priority(value) -> Vector(value))\n")),(0,a.kt)("p",null,"Now, we define some useful priority-queue methods as extensions on our type. To\n",(0,a.kt)("inlineCode",{parentName:"p"},"enqueue")," a value, we update the map; if no entry exists for the priority, we insert\na new vector; otherwise, we update the map with the new value appended to the existing\nvector. To ",(0,a.kt)("inlineCode",{parentName:"p"},"enqueueAll")," a series of values we just fold over the queue, appending each\nvalue individually. To ",(0,a.kt)("inlineCode",{parentName:"p"},"dequeue")," we take the first element of the map, which is a\ntuple of the priority and vector. If the vector has a single element, we return that\nelement and the map with the priority removed. Otherwise we return the first element\nand the map, with the priority updated to the tail."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"extension [K, V](queue: PriorityQueue[K, V])\n  def enqueue(value: V)(using P: Priority[K, V]): PriorityQueue[K, V] =\n    queue.updatedWith(P.priority(value)):\n      case Some(values) => Some(values :+ value)\n      case None         => Some(Vector(value))\n\n  def enqueueAll(values: Iterable[V])(using P: Priority[K, V]): PriorityQueue[K, V] =\n    values.foldLeft(queue)(_.enqueue(_))\n\n  def dequeue: (V, PriorityQueue[K, V]) =\n    val (priority, values) = queue.head\n    if values.size == 1 then (values.head, queue - priority)\n    else (values.head, queue + (priority -> values.tail))\n\n  def firstValue: V = firstValues.head\n\n  def firstValues: Vector[V] = queue.valuesIterator.next()\n")),(0,a.kt)("h4",{id:"reindeer"},"Reindeer"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Reindeer")," class represents one of the values in our priority queue; it encapsulates\na position in the maze, a direction, and the score (the cost to reach this position and\ndirection). It provides a ",(0,a.kt)("inlineCode",{parentName:"p"},"neighbours")," method that returns the three effective neighbour\npositions in the maze; this is stepping forwards at a score of 1, or rotating in either\ndirection at a score of 1000. We also provide ",(0,a.kt)("inlineCode",{parentName:"p"},"Priority")," evidence for extracting the\npriority (score)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"case class Reindeer(score: Int, pos: Position, dir: Direction):\n  def neighbours: Vector[Reindeer] = Vector(\n    Reindeer(score + 1, pos + dir, dir),\n    Reindeer(score + 1000, pos, dir.cw),\n    Reindeer(score + 1000, pos, dir.ccw)\n  )\n\ngiven Priority[Int, Reindeer] = _.score\n")),(0,a.kt)("h2",{id:"part-1"},"Part 1"),(0,a.kt)("p",null,"Solving part 1 is then just running Dijkstra's algorithm. To do this using immutable\ndata structures we will use ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator.iterate")," to step through a state machine, where\neach state is the current priority queue and visited location set."),(0,a.kt)("p",null,"Our state is represented by ",(0,a.kt)("inlineCode",{parentName:"p"},"ReindeerState"),". For ease of use, we include the maze and\nend location in the state. The ",(0,a.kt)("inlineCode",{parentName:"p"},"nextState")," method then computes a next state by\ndequeueing the first (lowest-score) reindeer, finding all its valid neighbours (where\nwe have not already  visited the location and direction, and it is not in a wall) and\nthen returning a new state with the updated queue and visited set."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"case class ReindeerState(\n  maze: Maze,\n  end: Position,\n  queue: PriorityQueue[Int, Reindeer],\n  visited: Set[(Position, Direction)],\n):\n  def nextState: ReindeerState =\n    val (reindeer, rest) = queue.dequeue\n\n    val neighbours = reindeer.neighbours.filter: next =>\n      maze(next.pos) != '#' && !visited(next.pos -> next.dir)\n\n    ReindeerState(\n      maze,\n      end,\n      rest.enqueueAll(neighbours),\n      visited + (reindeer.pos -> reindeer.dir),\n    )\n")),(0,a.kt)("p",null,"We define a ",(0,a.kt)("inlineCode",{parentName:"p"},"solution1")," method that returns the solution to the first puzzle. If\nthe head reindeer has reached the end location, then its score is the solution to the\nproblem. The search algorithm guarantees that the front of the queue is always the\nlowest cost answer."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def solution1: Option[Int] =\n  Option(queue.firstValue).filter(_.pos == end).map(_.score)\n")),(0,a.kt)("p",null,"To construct the initial state from the input string, we split the string into\nmultiple lines, which is our maze. We then find the start and end, which are the\npositions of the",(0,a.kt)("inlineCode",{parentName:"p"},"S")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"E")," characters in the maze. Our first reindeer starts on\nthe start location, facing east with zero cost. From these we construct the initial\n",(0,a.kt)("inlineCode",{parentName:"p"},"ReindeerState"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"object ReindeerState:\n  def apply(input: String): ReindeerState =\n    val maze     = input.split(\"\\n\")\n    val start    = maze.findPosition('S').get\n    val end      = maze.findPosition('E').get\n    val reindeer = Reindeer(0, start, East)\n    new ReindeerState(maze, end, PriorityQueue(reindeer), Set.empty)\n")),(0,a.kt)("p",null,"Now that we've put everything together, we can solve the problem as follows:\nConstruct an ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator")," that starts with the initial state and steps through\neach subsequent state by invoking ",(0,a.kt)("inlineCode",{parentName:"p"},"nextState"),". We run this until ",(0,a.kt)("inlineCode",{parentName:"p"},"solution1"),"\nreturns a value, then we return this value."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def part1(input: String): Int =\n  Iterator\n    .iterate(ReindeerState(input)): state =>\n      state.nextState\n    .flatMap: state =>\n      state.solution1\n    .next()\n")),(0,a.kt)("h2",{id:"part-2"},"Part 2"),(0,a.kt)("p",null,"Part 2 asks us to find how many locations are on any of the shortest-path\nsolutions to the problem. To solve this with our current code, we will run\nthe algorithm for part 1, but when we reach a solution, we will then look at\nthe front of the queue for all the reindeer that have reached the end at the same\ntime and take the union all of their paths. Because we are using a priority queue,\nall the best solutions will be at the front of the queue."),(0,a.kt)("p",null,"To solve this, we will add to each ",(0,a.kt)("inlineCode",{parentName:"p"},"Reindeer")," the path that they have walked to their current position:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"case class Reindeer(score: Int, pos: Position, dir: Direction, path: Vector[Position]):\n  def neighbours: Vector[Reindeer] = Vector(\n    Reindeer(score + 1, pos + dir, dir, path :+ (pos + dir)),\n    Reindeer(score + 1000, pos, dir.cw, path),\n    Reindeer(score + 1000, pos, dir.ccw, path)\n  )\n")),(0,a.kt)("p",null,"Our solution function, ",(0,a.kt)("inlineCode",{parentName:"p"},"solution2")," uses this to union all the best paths;\nwe take the front vector from the queue, filter for those that are at the\nend and count the distinct positions on their paths."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def solution2: Option[Int] =\n  Option.when(queue.firstValue.pos == end):\n    queue.firstValues.filter(_.pos == end).flatMap(_.path).distinct.size\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator")," solution code is then identical to part 1."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"def part2(input: String): Int =\n  Iterator\n    .iterate(ReindeerState(input)): state =>\n      state.nextState\n    .flatMap: state =>\n      state.solution2\n    .next()\n")),(0,a.kt)("h2",{id:"final-code"},"Final Code"),(0,a.kt)("p",null,"The final complete code is the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"import scala.collection.immutable.TreeMap\n\ndef part1(input: String): Int =\n  Iterator\n    .iterate(ReindeerState(input)): state =>\n      state.nextState\n    .flatMap: state =>\n      state.solution1\n    .next()\n\ndef part2(input: String): Int =\n  Iterator\n    .iterate(ReindeerState(input)): state =>\n      state.nextState\n    .flatMap: state =>\n      state.solution2\n    .next()\n\ncase class Reindeer(score: Int, pos: Position, dir: Direction, path: Vector[Position]):\n  def neighbours: Vector[Reindeer] = Vector(\n    Reindeer(score + 1, pos + dir, dir, path :+ (pos + dir)),\n    Reindeer(score + 1000, pos, dir.cw, path),\n    Reindeer(score + 1000, pos, dir.ccw, path)\n  )\n\ngiven Priority[Int, Reindeer] = _.score\n\ncase class ReindeerState(\n  maze: Maze,\n  end: Position,\n  queue: PriorityQueue[Int, Reindeer],\n  visited: Set[(Position, Direction)],\n):\n  def nextState: ReindeerState =\n    val (reindeer, rest) = queue.dequeue\n\n    val neighbours = reindeer.neighbours.filter: next =>\n      maze(next.pos) != '#' && !visited(next.pos -> next.dir)\n\n    ReindeerState(\n      maze,\n      end,\n      rest.enqueueAll(neighbours),\n      visited + (reindeer.pos -> reindeer.dir),\n    )\n\n  def solution1: Option[Int] =\n    Option(queue.firstValue).filter(_.pos == end).map(_.score)\n\n  def solution2: Option[Int] =\n    Option.when(queue.firstValue.pos == end):\n      queue.firstValues.filter(_.pos == end).flatMap(_.path).distinct.size\n\nobject ReindeerState:\n  def apply(input: String): ReindeerState =\n    val maze     = input.split(\"\\n\")\n    val start    = maze.findPosition('S').get\n    val end      = maze.findPosition('E').get\n    val reindeer = Reindeer(0, start, East, Vector(start))\n    new ReindeerState(maze, end, PriorityQueue(reindeer), Set.empty)\n\ntype Signum = -1 | 0 | 1\n\nextension (signum: Signum) def reverse: Signum = if signum == 1 then -1 else if signum == -1 then 1 else 0\n\ntype Direction = (Signum, Signum)\n\nval East: Direction = (1, 0)\n\nextension (direction: Direction)\n  def cw: Direction  = (direction(1).reverse, direction(0))\n  def ccw: Direction = (direction(1), direction(0).reverse)\n\ntype Position = (Int, Int)\n\nextension (position: Position)\n  def +(direction: Direction): Position = (position(0) + direction(0), position(1) + direction(1))\n\ntype Maze = Array[String]\n\nextension (maze: Maze)\n  def findPosition(char: Char): Option[Position] =\n    maze.zipWithIndex.collectFirst:\n      case (row, y) if row.contains(char) => row.indexOf(char) -> y\n\n  def apply(position: Position): Char = maze(position(1))(position(0))\n\ntype PriorityQueue[K, V] = TreeMap[K, Vector[V]]\n\ntrait Priority[K, V]:\n  def priority(value: V): K\n\nobject PriorityQueue:\n  def apply[K: Ordering, V](value: V)(using P: Priority[K, V]): PriorityQueue[K, V] =\n    TreeMap(P.priority(value) -> Vector(value))\n\nextension [K, V](queue: PriorityQueue[K, V])\n  def enqueue(value: V)(using P: Priority[K, V]): PriorityQueue[K, V] =\n    queue.updatedWith(P.priority(value)):\n      case Some(values) => Some(values :+ value)\n      case None         => Some(Vector(value))\n\n  def enqueueAll(values: Iterable[V])(using P: Priority[K, V]): PriorityQueue[K, V] =\n    values.foldLeft(queue)(_.enqueue(_))\n\n  def dequeue: (V, PriorityQueue[K, V]) =\n    val (priority, values) = queue.head\n    if values.size == 1 then (values.head, queue - priority)\n    else (values.head, queue + (priority -> values.tail))\n\n  def firstValue: V = firstValues.head\n\n  def firstValues: Vector[V] = queue.valuesIterator.next()\n")),(0,a.kt)("h3",{id:"mutable-solution"},"Mutable solution"),(0,a.kt)("p",null,"For the interested (but unprincipled), the (shorter and faster, but unprincipled) mutable version is as\nfollows: Instead of state carrying an immutable queue and visited set, we just iteratively\nupdate a mutable queue and set. The immutable solution can actually be brought up to speed\nwith the mutable version with just a small update to iterate in chunks, so performance is\nnot really a deciding factor between the solutions."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",3:!0,className:"language-scala",metastring:"3"},"import scala.collection.mutable\n\ndef part1(input: String): Int =\n  val (reindeer, _) = solve(input)\n  reindeer.score\n\ndef part2(input: String): Int =\n  val (reindeer, queue) = solve(input)\n  val paths             = mutable.Set.from(reindeer.path)\n  while queue.head.score == reindeer.score do\n    val next = queue.dequeue()\n    if next.pos == reindeer.pos then paths.addAll(next.path)\n  paths.size\n\ndef solve(input: String): (Reindeer, mutable.PriorityQueue[Reindeer]) =\n  val maze     = input.split(\"\\n\")\n  val start    = maze.findPosition('S').get\n  val end      = maze.findPosition('E').get\n  val reindeer = Reindeer(0, start, East, Vector(start))\n  val visited  = mutable.Set.empty[(Position, Direction)]\n  val queue    = mutable.PriorityQueue.from(Seq(reindeer))\n\n  while queue.head.pos != end do\n    val reindeer = queue.dequeue()\n\n    val neighbours = reindeer.neighbours.filter: next =>\n      maze(next.pos) != '#' && !visited(next.pos -> next.dir)\n\n    visited.addOne(reindeer.pos -> reindeer.dir)\n    queue.addAll(neighbours)\n\n  (queue.dequeue(), queue)\n\ncase class Reindeer(score: Int, pos: Position, dir: Direction, path: Vector[Position]):\n  def neighbours: Vector[Reindeer] = Vector(\n    Reindeer(score + 1, pos + dir, dir, path :+ (pos + dir)),\n    Reindeer(score + 1000, pos, dir.cw, path),\n    Reindeer(score + 1000, pos, dir.ccw, path)\n  )\n\ngiven Ordering[Reindeer] = Ordering.by(-_.score)\n")),(0,a.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/aoc2024/blob/main/src/main/scala/Day16.scala"},"Solution")," by ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/merlinorg"},"merlinorg")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/nikiforo/aoc24/blob/main/src/main/scala/io/github/nikiforo/aoc24/D16T2.scala"},"Solution")," by ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/nikiforo"},"Artem Nikiforov")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2024/blob/main/src/main/scala/ch/aamiguet/advent2024/Day16.scala"},"Solution")," by ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/AlexMckey/AoC2024_Scala/blob/master/src/year2024/day16.scala"},"Solution")," by ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/AlexMckey"},"Alex Mc'key")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2024/blob/main/day16/src/main/scala/Solution.scala"},"Solution")," by ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/TheDrawingCoder-Gamer/adventofcode2024/blob/master/src/main/scala/Day16.scala"},"Solution")," by ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/TheDrawingCoder-Gamer"},"Bulby"))),(0,a.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}p.isMDXComponent=!0}}]);