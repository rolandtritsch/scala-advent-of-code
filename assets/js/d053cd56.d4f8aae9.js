"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8819],{7668:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>s});var n=t(7462),o=(t(7294),t(3905));t(6340);const l={},i="Day 13: Claw Contraption",r={unversionedId:"2024/puzzles/day13",id:"2024/puzzles/day13",title:"Day 13: Claw Contraption",description:"by @scarf005",source:"@site/target/mdoc/2024/puzzles/day13.md",sourceDirName:"2024/puzzles",slug:"/2024/puzzles/day13",permalink:"/scala-advent-of-code/2024/puzzles/day13",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2024/puzzles/day13.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 12: Garden Groups",permalink:"/scala-advent-of-code/2024/puzzles/day12"},next:{title:"Day 14: Restroom Redoubt",permalink:"/scala-advent-of-code/2024/puzzles/day14"}},p={},s=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution Summary",id:"solution-summary",level:2},{value:"Parsing",id:"parsing",level:2},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Final Solution",id:"final-solution",level:2},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],c={toc:s};function u(e){let{components:a,...t}=e;return(0,o.kt)("wrapper",(0,n.Z)({},c,t,{components:a,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"day-13-claw-contraption"},"Day 13: Claw Contraption"),(0,o.kt)("p",null,"by ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/scarf005"},"@scarf005")),(0,o.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://adventofcode.com/2024/day/13"},"https://adventofcode.com/2024/day/13")),(0,o.kt)("h2",{id:"solution-summary"},"Solution Summary"),(0,o.kt)("p",null,"This problem requires you to work with equations and numbers."),(0,o.kt)("p",null,"Both parts of the problem ask you to calculate the smallest number of tokens needed to win as many prizes as possible, which means to calculate the optimal number of A and B button presses."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"For part 1, the question assures you that buttons are pressed no more than 100 times, so it can simply be brute forced for all possible combinations."),(0,o.kt)("li",{parentName:"ul"},"For part 2, the position of prize is higher by 10000000000000, which means a brute-force approach is not feasible. We need to use the power of math to calculate the optimal solution.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"First, describe the relation between button presses and prize position as a multivariable equation."),(0,o.kt)("li",{parentName:"ul"},"Then, use algebraic properties to simplify the equation."),(0,o.kt)("li",{parentName:"ul"},"This way, we reduce the complexity of the problem to ",(0,o.kt)("inlineCode",{parentName:"li"},"O(1)"),".")))),(0,o.kt)("h2",{id:"parsing"},"Parsing"),(0,o.kt)("p",null,"The input data is quite complex to parse. First, let's create a case class to store the amount of claw movements and the prize position:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class Claw(ax: Long, ay: Long, bx: Long, by: Long, x: Long, y: Long)\n")),(0,o.kt)("p",null,"Since a lot of numbers need to be parsed, ",(0,o.kt)("a",{parentName:"p",href:"https://docs.scala-lang.org/tour/extractor-objects.html"},"Extractor Objects")," come in handy. this ",(0,o.kt)("inlineCode",{parentName:"p"},"L")," object with an ",(0,o.kt)("inlineCode",{parentName:"p"},"unapply")," method will parse a string to ",(0,o.kt)("inlineCode",{parentName:"p"},"Long"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"object L:\n  def unapply(s: String): Option[Long] = s.toLongOption\n")),(0,o.kt)("p",null,"Then the inputs can be pattern-matched, like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'object Claw:\n  def parse(xs: Seq[String]): Option[Claw] = xs match\n    case Seq(\n          s"Button A: X+${L(ax)}, Y+${L(ay)}",\n          s"Button B: X+${L(bx)}, Y+${L(by)}",\n          s"Prize: X=${L(x)}, Y=${L(y)}",\n        ) =>\n      Some(Claw(ax, ay, bx, by, x, y))\n    case _ => None\n')),(0,o.kt)("p",null,"To use ",(0,o.kt)("inlineCode",{parentName:"p"},"Claw.parse"),", we need to pass 3 lines at a time. We can use ",(0,o.kt)("inlineCode",{parentName:"p"},".split")," and ",(0,o.kt)("inlineCode",{parentName:"p"},".grouped"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'def parse(input: String): Seq[Claw] =\n  input.split("\\n+").toSeq.grouped(3).flatMap(Claw.parse).toSeq\n')),(0,o.kt)("h3",{id:"part-1"},"Part 1"),(0,o.kt)("p",null,"Brute forcing part 1 is trivial; as the upper bound of button press is 100, we can just try all ",(0,o.kt)("inlineCode",{parentName:"p"},"10,000")," combinations:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def part1(input: String): Long =\n  def solve(c: Claw) =\n    for\n      a <- 0 to 100\n      b <- 0 to 100\n      if a * c.ax + b * c.bx == c.x\n      if a * c.ay + b * c.by == c.y\n    yield (a * 3L + b)\n\n  parse(input).flatMap(solve).sum\n")),(0,o.kt)("h3",{id:"part-2"},"Part 2"),(0,o.kt)("p",null,"However, we need to completely ditch our day 1 solution, because now our targets are suddenly farther by 10 ",(0,o.kt)("em",{parentName:"p"},"trillion"),". We won't be able to run it till the heat death of the universe! (probably)"),(0,o.kt)("p",null,"We need another approach. Let's look at the condition carefully..."),(0,o.kt)("p",null,"Turns out we can express it using system of equations! For number of button presses ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"B"),", our target ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," can be described as following equation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-math"},"\\begin{cases}\nA \\cdot ax + B \\cdot bx = x \\\\\nA \\cdot ay + B \\cdot by = y\n\\end{cases}\n")),(0,o.kt)("p",null,"Which can be solved for ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," in terms of ",(0,o.kt)("inlineCode",{parentName:"p"},"B"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-math"},"A = \\frac{x - B \\cdot bx}{ax}, \\quad A = \\frac{y - B \\cdot by}{ay}\n")),(0,o.kt)("p",null,"Then ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," can be equated in both expressions:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-math"},"\\frac{x - B \\cdot bx}{ax} = \\frac{y - B \\cdot by}{ay}\n")),(0,o.kt)("p",null,"Now ",(0,o.kt)("inlineCode",{parentName:"p"},"ax")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ay")," can be cross-multiplied to eliminate denominators:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-math"},"(x - B \\cdot bx) \\cdot ay = (y - B \\cdot by) \\cdot ax\n")),(0,o.kt)("p",null,"...Expand and rearrange:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-math"},"x \\cdot ay - B \\cdot bx \\cdot ay = y \\cdot ax - B \\cdot by \\cdot ax\n")),(0,o.kt)("p",null,"Group terms involving ",(0,o.kt)("inlineCode",{parentName:"p"},"B"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-math"},"x \\cdot ay - y \\cdot ax = B \\cdot (bx \\cdot ay - by \\cdot ax)\n")),(0,o.kt)("p",null,"Then solve for ",(0,o.kt)("inlineCode",{parentName:"p"},"B"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-math"},"B = \\frac{x \\cdot ay - y \\cdot ax}{bx \\cdot ay - by \\cdot ax}\n")),(0,o.kt)("p",null,"Using ",(0,o.kt)("inlineCode",{parentName:"p"},"B"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," can also be solved:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-math"},"A = \\frac{x - B \\cdot bx}{ax}\n")),(0,o.kt)("p",null,"There's two more important requirement for ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"B"),":"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"A")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"B")," should both be an natural number."),(0,o.kt)("li",{parentName:"ol"},"denominator musn't be ",(0,o.kt)("inlineCode",{parentName:"li"},"0")," (divide by zero!)")),(0,o.kt)("p",null,"Let's write a ",(0,o.kt)("inlineCode",{parentName:"p"},"safeDiv")," function to address them:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"extension (a: Long)\n  infix def safeDiv(b: Long): Option[Long] =\n    Option.when(b != 0 && a % b == 0)(a / b)\n")),(0,o.kt)("p",null,"we check that denominator is not zero and that numerator is divisible by denominator."),(0,o.kt)("p",null,"With the help of ",(0,o.kt)("inlineCode",{parentName:"p"},"safeDiv"),", the solution can be cleanly expressed as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class Claw(ax: Long, ay: Long, bx: Long, by: Long, x: Long, y: Long):\n  def solve: Option[Long] = for\n    b <- (x * ay - y * ax) safeDiv (bx * ay - by * ax)\n    a <- (x - b * bx) safeDiv ax\n  yield a * 3 + b\n")),(0,o.kt)("p",null,"also don't forget to add 10000000000000 to the prize position:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"def part2(input: String): Long =\n  val diff = 10_000_000_000_000L\n  parse(input)\n    .map(c => c.copy(x = c.x + diff, y = c.y + diff))\n    .flatMap(_.solve)\n    .sum\n")),(0,o.kt)("h2",{id:"final-solution"},"Final Solution"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'extension (a: Long)\n  infix def safeDiv(b: Long): Option[Long] =\n    Option.when(b != 0 && a % b == 0)(a / b)\n\ncase class Claw(ax: Long, ay: Long, bx: Long, by: Long, x: Long, y: Long):\n  def solve: Option[Long] = for\n    b <- (x * ay - y * ax) safeDiv (bx * ay - by * ax)\n    a <- (x - b * bx) safeDiv ax\n  yield a * 3 + b\n\nobject L:\n  def unapply(s: String): Option[Long] = s.toLongOption\n\nobject Claw:\n  def parse(xs: Seq[String]): Option[Claw] = xs match\n    case Seq(\n          s"Button A: X+${L(ax)}, Y+${L(ay)}",\n          s"Button B: X+${L(bx)}, Y+${L(by)}",\n          s"Prize: X=${L(x)}, Y=${L(y)}",\n        ) =>\n      Some(Claw(ax, ay, bx, by, x, y))\n    case _ => None\n\ndef parse(input: String): Seq[Claw] =\n  input.split("\\n+").toSeq.grouped(3).flatMap(Claw.parse).toSeq\n\ndef part1(input: String): Long =\n  parse(input).flatMap(_.solve).sum\n\ndef part2(input: String): Long =\n  val diff = 10_000_000_000_000L\n  parse(input)\n    .map(c => c.copy(x = c.x + diff, y = c.y + diff))\n    .flatMap(_.solve)\n    .sum\n')),(0,o.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2024/blob/main/day13/src/main/scala/Solution.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/spamegg1/aoc/blob/master/2024/13/13.worksheet.sc#L109"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/spamegg1"},"Spamegg")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2024/blob/main/src/main/scala/ch/aamiguet/advent2024/Day13.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/scarf005/aoc-scala/blob/main/2024/day13.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/scarf005"},"scarf")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/aoc2024/blob/main/src/main/scala/Day13.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/merlinorg"},"merlinorg")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://gist.github.com/mbovel/f26d82b2fd3d46cb55520268994371f8"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/mbovel"},"mbovel")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2024/Day13.scala"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/jnclt/adventofcode2024/blob/main/day13/claw-contraption.sc"},"Solution")," by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/jnclt"},"jnclt"))),(0,o.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}u.isMDXComponent=!0}}]);