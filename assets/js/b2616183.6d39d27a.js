"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8685],{3382:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>i,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var o=a(7462),n=(a(7294),a(3905));a(6340);const l={},r="Day 15: Warehouse Woes",s={unversionedId:"2024/puzzles/day15",id:"2024/puzzles/day15",title:"Day 15: Warehouse Woes",description:"by @shardulc",source:"@site/target/mdoc/2024/puzzles/day15.md",sourceDirName:"2024/puzzles",slug:"/2024/puzzles/day15",permalink:"/scala-advent-of-code/2024/puzzles/day15",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2024/puzzles/day15.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 14: Restroom Redoubt",permalink:"/scala-advent-of-code/2024/puzzles/day14"},next:{title:"Day 16: Reindeer Maze",permalink:"/scala-advent-of-code/2024/puzzles/day16"}},i={},p=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Solution",id:"solution",level:2},{value:"Summary",id:"summary",level:3},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Final code",id:"final-code",level:3},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],c={toc:p};function h(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,o.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"day-15-warehouse-woes"},"Day 15: Warehouse Woes"),(0,n.kt)("p",null,"by ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/shardulc"},"@shardulc")),(0,n.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://adventofcode.com/2024/day/15"},"https://adventofcode.com/2024/day/15")),(0,n.kt)("h2",{id:"solution"},"Solution"),(0,n.kt)("h3",{id:"summary"},"Summary"),(0,n.kt)("p",null,"When building a grid-based simulation like for this puzzle, my preferred approach is to use an immutable 2D array representation for the grid and make an updated copy at every step. Then, to run the simulation is simply to compute a ",(0,n.kt)("em",{parentName:"p"},"fold")," of the moves over the (grid) state. I value the ease (for me) of programming and reasoning about the resulting program over the run-time costs of allocation, garbage collection, etc."),(0,n.kt)("p",null,"(With a mutable array, we\u2019d have to be careful not to, say, overwrite an old box before it has been moved to its new position, and I don\u2019t trust myself to reason that carefully. We could alternatively use a collection of objects with their positions instead of an array, which would make more sense for sparse grids, as finding adjacent objects would require traversing the entire collection.)"),(0,n.kt)("p",null,"Some preliminaries: enums to represent grid cells and move directions\u2026"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"enum WarehouseCell:\n  case Empty\n  case Wall\n  case Box\n  case LeftBox\n  case RightBox\n  case Robot\n\nenum Direction:\n  case Up\n  case Down\n  case Left\n  case Right\n")),(0,n.kt)("p",null,"\u2026and a class to represent the state. In addition to the grid, we choose to (redundantly) track the position of the robot, since there\u2019s only one and we might want its position often and don\u2019t want to traverse the grid to find it every time."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"class Warehouse(\n    val cells: ArraySeq[ArraySeq[WarehouseCell]],\n    val robotRow: Int,\n    val robotCol: Int)\n")),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"NB:")," We use ",(0,n.kt)("inlineCode",{parentName:"p"},"collection.immutable.ArraySeq"),"s instead of ",(0,n.kt)("inlineCode",{parentName:"p"},"Array"),"s to guarantee that we don\u2019t accidentally mutate them in our program. ",(0,n.kt)("inlineCode",{parentName:"p"},"ArraySeq"),", like ",(0,n.kt)("inlineCode",{parentName:"p"},"Array")," but unlike ",(0,n.kt)("inlineCode",{parentName:"p"},"Seq"),", guarantees constant-time random access (we\u2019ll be doing that a lot) and benefits from the fact that the size of the collection never changes."),(0,n.kt)("h3",{id:"part-1"},"Part 1"),(0,n.kt)("p",null,"We start with the parser. First, we\u2019ll need a way to create ",(0,n.kt)("inlineCode",{parentName:"p"},"Direction")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"WarehouseCell")," objects from their ",(0,n.kt)("inlineCode",{parentName:"p"},"Char")," representations. We could either write a simple pattern match:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"object Direction:\n  def ofChar(c: Char) =\n    c match\n      case '^' => Up\n      case 'v' => Down\n      case '>' => Right\n      case '<' => Left\n")),(0,n.kt)("p",null,"Or we could make the enum parametric, and use the parameter to define a ",(0,n.kt)("inlineCode",{parentName:"p"},"Map")," (which we can automatically use as a ",(0,n.kt)("inlineCode",{parentName:"p"},"Char => WarehouseCell")," function due to its ",(0,n.kt)("inlineCode",{parentName:"p"},"apply")," method):"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"enum WarehouseCell(val repr: Char):\n  case Empty extends WarehouseCell('.')\n  case Wall extends WarehouseCell('#')\n  case Box extends WarehouseCell('O')\n  case Robot extends WarehouseCell('@')\n\nobject WarehouseCell:\n  val ofChar = Map.from(Seq(Wall, Box, Empty, Robot).map(c => (c.repr, c)))\n")),(0,n.kt)("p",null,"As a personal challenge, I try to parse without reading the entire input into memory at once, only using the ",(0,n.kt)("inlineCode",{parentName:"p"},"File.getLines()")," iterator and standard iterable methods."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"object Day15:\n  def parseMoves(input: Iterator[String]): Seq[Direction] =\n    // extra flatMap because the moves may be split across multiple lines\n    input.flatMap(_.map(Direction.ofChar)).toSeq\n\n  def parse(inputFile: String): (Warehouse, Seq[Direction]) =\n    val file = io.Source.fromFile(inputFile)\n    try\n      val input = file.getLines()\n      val cells = ArraySeq.from(input\n        // an empty line separates the grid from the moves\n        .takeWhile(!_.isEmpty)\n        .map(l => ArraySeq.from(l.toCharArray()).map(WarehouseCell.ofChar)))\n      val robotRow = cells.indexWhere(_.contains(WarehouseCell.Robot))\n      val robotCol = cells(robotRow).indexOf(WarehouseCell.Robot)\n      (Warehouse(cells, robotRow, robotCol), parseMoves(input))\n    finally\n      file.close()\n")),(0,n.kt)("p",null,"(We could save a couple traversals by detecting the robot while reading the input, using either a ",(0,n.kt)("inlineCode",{parentName:"p"},"var")," to store its position or writing it as a fold, but the code is more elegant this way and performance is not critical.)"),(0,n.kt)("p",null,"Now, we compute the result of a single move instruction. In ",(0,n.kt)("inlineCode",{parentName:"p"},"getStackLengthFromTowards"),", we either find the length of the stack of adjacent boxes that can successfully be pushed in the given direction (i.e., the cell after those boxes is empty) by checking just the next one and then recursing, or producing ",(0,n.kt)("inlineCode",{parentName:"p"},"None")," if they will push against a wall or go out of bounds. The ",(0,n.kt)("inlineCode",{parentName:"p"},"move")," method uses ",(0,n.kt)("inlineCode",{parentName:"p"},"getStackLengthFromTowards"),", starting from the robot\u2019s position, to update the grid."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},'class Warehouse:\n  /* ... */\n\n  def getStackLengthFromTowards(posRow: Int, posCol: Int, d: Direction): Option[Int] =\n    val (nextRow, nextCol) = d(posRow, posCol)\n    cells.lift(nextRow).flatMap(_.lift(nextCol))\n      .flatMap(_ match\n        case WarehouseCell.Empty => Some(0)\n        case WarehouseCell.Wall => None\n        case WarehouseCell.Box =>\n          getStackLengthFromTowards(nextRow, nextCol, d).map(_ + 1)\n        case WarehouseCell.Robot =>\n          throw AssertionError("should not reach robot in traversal"))\n\n  def move(d: Direction): Warehouse =\n    getStackLengthFromTowards(robotRow, robotCol, d) match\n      case None => this\n      case Some(stackLength) =>\n        val (newRobotRow, newRobotCol) = d(robotRow, robotCol)\n        val newCells = cells.updated(Seq(\n          ((robotRow, robotCol), WarehouseCell.Empty),\n          ((newRobotRow, newRobotCol), WarehouseCell.Robot)) ++\n          (if stackLength > 0\n           // stackLength + 1 because we want the cell after the stack\n           then Seq((d(robotRow, robotCol, stackLength + 1), WarehouseCell.Box))\n           else Seq(/* only the robot moves */)))\n        Warehouse(newCells, newRobotRow, newRobotCol)\n')),(0,n.kt)("p",null,"Some nifty Scala features at play:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Applying ",(0,n.kt)("inlineCode",{parentName:"p"},"ArraySeq.apply")," to an index out of bounds would result in an exception. However, ",(0,n.kt)("inlineCode",{parentName:"p"},"ArraySeq")," also defines an ",(0,n.kt)("inlineCode",{parentName:"p"},"isDefinedAt")," method, making it a ",(0,n.kt)("inlineCode",{parentName:"p"},"PartialFunction"),". Then ",(0,n.kt)("inlineCode",{parentName:"p"},"lift")," lets us turn it into an ",(0,n.kt)("inlineCode",{parentName:"p"},"Option"),"-valued one, which we can further ",(0,n.kt)("inlineCode",{parentName:"p"},"flatMap")," with the ",(0,n.kt)("inlineCode",{parentName:"p"},"Option"),"-valued wall/box/empty logic. (Alternatively, we could do all this by handling and throwing exceptions ourselves.)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"We define an ",(0,n.kt)("inlineCode",{parentName:"p"},"apply")," method on ",(0,n.kt)("inlineCode",{parentName:"p"},"Direction")," so that we can compute the updated position for ",(0,n.kt)("inlineCode",{parentName:"p"},"(row, col)")," in direction ",(0,n.kt)("inlineCode",{parentName:"p"},"d")," simply as ",(0,n.kt)("inlineCode",{parentName:"p"},"d(row, col)")," (or optionally repeatedly, ",(0,n.kt)("inlineCode",{parentName:"p"},"d(row, col, n)"),")."),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"enum Direction:\n  /* ... */\n  def apply(row: Int, col: Int, n: Int = 1): (Int, Int) =\n    this match\n      case Up => (row - n, col)\n      case Down => (row + n, col)\n      case Left => (row, col - n)\n      case Right => (row, col + n)\n"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"ArraySeq"),"s (like other immutable collections) provide an ",(0,n.kt)("inlineCode",{parentName:"p"},"updated")," method that produces a new ",(0,n.kt)("inlineCode",{parentName:"p"},"ArraySeq")," with just one element changed. That is sufficient for our needs, but we can make it even easier for ourselves with our own ",(0,n.kt)("inlineCode",{parentName:"p"},"updated")," that does the same but for multiple elements at once, and with 2D indices rather than 2 levels of nesting. This is the only place we will make use of mutation in this program and we will be very careful about it."),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"extension (cells: ArraySeq[ArraySeq[WarehouseCell]])\n                             // ((row, col), new cell)\n  def updated(updates: Iterable[((Int, Int), WarehouseCell)])\n      : ArraySeq[ArraySeq[WarehouseCell]] =\n    // Construct a fresh array (*not* using the one backing the ArraySeq),\n    val newCells = cells.map(_.toArray).toArray\n                                                // mutate it,\n    updates.foreach{ case ((row, col), cell) => newCells(row)(col) = cell }\n    // and construct a new ArraySeq backed by it. Possibly unsafe if the\n    // backing array remains accessible outside of the ArraySeq, but safe\n    // here because the method only returns the ArraySeq.\n    ArraySeq.unsafeWrapArray(newCells).map(ArraySeq.unsafeWrapArray)\n")))),(0,n.kt)("p",null,"Lastly, the ",(0,n.kt)("inlineCode",{parentName:"p"},"score")," method zips each cell with its index, computes its score, and sums:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"class Warehouse:\n  /* ... */\n  def score: Int =\n    cells.iterator.zipWithIndex.flatMap((row, r) =>\n      row.iterator.zipWithIndex.map((cell, c) => cell match\n        case WarehouseCell.Box | WarehouseCell.LeftBox => 100*r + c\n        case _ => 0))\n      .sum\n")),(0,n.kt)("p",null,"And to tie it all together:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"object Day15:\n  /* ... */\n  def part1(inputFile: String): Int =\n    val (warehouse, moves) = parse(inputFile, WarehouseCell.ofChar)\n    moves.foldLeft(warehouse)((wh, d) => wh.move(d)).score\n")),(0,n.kt)("h3",{id:"part-2"},"Part 2"),(0,n.kt)("p",null,"We first need to update our parser. Instead of ",(0,n.kt)("inlineCode",{parentName:"p"},"map"),"ping each ",(0,n.kt)("inlineCode",{parentName:"p"},"Char")," to a ",(0,n.kt)("inlineCode",{parentName:"p"},"WarehouseCell"),", we can ",(0,n.kt)("inlineCode",{parentName:"p"},"flatMap")," it to a ",(0,n.kt)("inlineCode",{parentName:"p"},"Seq[WarehouseCell]")," that is always of length\xa01 in part\xa01 and length\xa02 in part\xa02 with the appropriate contents. Our ",(0,n.kt)("inlineCode",{parentName:"p"},"WarehouseCell")," definition also changes to accommodate wide boxes."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"enum WarehouseCell(val repr: Char):\n  case Empty extends WarehouseCell('.')\n  case Wall extends WarehouseCell('#')\n  case Box extends WarehouseCell('O')\n  case LeftBox extends WarehouseCell('[')\n  case RightBox extends WarehouseCell(']')\n  case Robot extends WarehouseCell('@')\n\nobject WarehouseCell:\n  val ofChar1 = Map.from(Seq(Wall, Box, Empty, Robot).map(c => (c.repr, Seq(c))))\n  val ofChar2 = Map(\n    '#' -> Seq(Wall, Wall),\n    'O' -> Seq(LeftBox, RightBox),\n    '.' -> Seq(Empty, Empty),\n    '@' -> Seq(Robot, Empty))\n")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"object Day15:\n  /* ... */\n  def parse(inputFile: String, cellMatcher: Char => Seq[WarehouseCell])\n      : (Warehouse, Seq[Direction]) =\n    val file = io.Source.fromFile(inputFile)\n    try\n      val input = file.getLines()\n      val cells = ArraySeq.from(input\n        // an empty line separates the grid from the moves\n        .takeWhile(!_.isEmpty)\n                                                // changed from part 1!\n        .map(l => ArraySeq.from(l.toCharArray()).flatMap(cellMatcher)))\n      val robotRow = cells.indexWhere(_.contains(WarehouseCell.Robot))\n      val robotCol = cells(robotRow).indexOf(WarehouseCell.Robot)\n      (Warehouse(cells, robotRow, robotCol), parseMoves(input))\n    finally\n      file.close()\n")),(0,n.kt)("p",null,"As for the move logic, I made a flawed assumption (a premature optimization?) in ",(0,n.kt)("inlineCode",{parentName:"p"},"getStackLengthFromTowards")," logic that the objects to move will always be a contiguous stack of cells, so that just knowing its length would be enough. We now change the code in two ways:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Fix the flawed assumption: instead of computing the stack length as an ",(0,n.kt)("inlineCode",{parentName:"li"},"Int"),", compute the positions of the objects to move as a ",(0,n.kt)("inlineCode",{parentName:"li"},"Seq[(Int, Int)]"),". (This is still inside an ",(0,n.kt)("inlineCode",{parentName:"li"},"Option")," representing whether the robot can move at all.)"),(0,n.kt)("li",{parentName:"ul"},"Adapt to the new \u201cwide box\u201d logic: when attempting to move a wide box up or down, recursively check the cells adjacent to both the left and right sides. As a small refinement, we implement this double recursive call in the ",(0,n.kt)("inlineCode",{parentName:"li"},"LeftBox")," case, and simply delegate to it from the ",(0,n.kt)("inlineCode",{parentName:"li"},"RightBox")," case; otherwise, even a straight stack of ",(0,n.kt)("em",{parentName:"li"},"n")," boxes would trigger ",(0,n.kt)("em",{parentName:"li"},"2^n")," recursive calls. We may still have some duplicated positions in the result (e.g.\xa0when there are two boxes pushing on the same box) but it doesn\u2019t matter too much.")),(0,n.kt)("p",null,"This method, now called ",(0,n.kt)("inlineCode",{parentName:"p"},"positionsToMove"),", preserves the part\xa01 computation and slightly simplifies the ",(0,n.kt)("inlineCode",{parentName:"p"},"move")," code too."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},'class Warehouse:\n  /* ... */\n  \n  def positionsToMove(posRow: Int, posCol: Int, d: Direction): Option[Seq[(Int, Int)]] =\n    val (nextRow, nextCol) = d(posRow, posCol)\n    cells.lift(nextRow).flatMap(_.lift(nextCol))\n      .flatMap((_, d) match\n        case (WarehouseCell.Empty, _) => Some(Nil)\n        case (WarehouseCell.Wall, _) => None\n        case (_, Direction.Left | Direction.Right) | (WarehouseCell.Box, _) =>\n          positionsToMove(nextRow, nextCol, d).map((nextRow, nextCol) +: _)\n        case (WarehouseCell.LeftBox, _) =>\n          positionsToMove(nextRow, nextCol, d).flatMap(posls =>\n            positionsToMove(nextRow, nextCol + 1, d).map(posrs =>\n              (nextRow, nextCol) +: (nextRow, nextCol + 1) +: (posls ++ posrs)))\n        case (WarehouseCell.RightBox, _) =>\n          positionsToMove(posRow, posCol - 1, d)\n        case (WarehouseCell.Robot, _) =>\n          throw AssertionError("should not reach robot in traversal"))\n\n  def move(d: Direction): Warehouse =\n    positionsToMove(robotRow, robotCol, d) match\n      case None => this\n      case Some(positions) =>\n        val positionsAndRobot = ((robotRow, robotCol) +: positions)\n        val newCells = cells\n          .updated(positionsAndRobot.map((_, WarehouseCell.Empty)))\n          .updated(positionsAndRobot\n            .map((row, col) => (d(row, col), cells(row)(col))))\n        val (newRobotRow, newRobotCol) = d(robotRow, robotCol)\n        Warehouse(newCells, newRobotRow, newRobotCol)\n')),(0,n.kt)("p",null,"Another nifty Scala feature: automatic tuple destructuring with the ",(0,n.kt)("inlineCode",{parentName:"p"},"(_ ,_)")," syntax and disjunctions with ",(0,n.kt)("inlineCode",{parentName:"p"},"|")," inside a pattern matching expression."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"(_, d) match\n  case (WarehouseCell.Empty, _) => /* ... */\n  case (WarehouseCell.Wall, _) => /* ... */\n  case (_, Direction.Left | Direction.Right) | (WarehouseCell.Box, _) => /* ... */\n  case (WarehouseCell.LeftBox, _) => /* ... */\n  case (WarehouseCell.RightBox, _) => /* ... */\n  case (WarehouseCell.Robot, _) => /* ... */\n")),(0,n.kt)("p",null,"And that\u2019s it! Being able to write a single program that can solve both parts was satisfying."),(0,n.kt)("h3",{id:"final-code"},"Final code"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"import collection.immutable.ArraySeq\n\nextension (cells: ArraySeq[ArraySeq[WarehouseCell]])\n  def updated(updates: Iterable[((Int, Int), WarehouseCell)])\n      : ArraySeq[ArraySeq[WarehouseCell]] =\n    val newCells = cells.map(_.toArray).toArray\n    updates.foreach{ case ((row, col), cell) => newCells(row)(col) = cell }\n    ArraySeq.unsafeWrapArray(newCells).map(ArraySeq.unsafeWrapArray)\n\n\nenum WarehouseCell(val repr: Char):\n  case Empty extends WarehouseCell('.')\n  case Wall extends WarehouseCell('#')\n  case Box extends WarehouseCell('O')\n  case LeftBox extends WarehouseCell('[')\n  case RightBox extends WarehouseCell(']')\n  case Robot extends WarehouseCell('@')\n\nobject WarehouseCell:\n  val ofChar1 = Map.from(Seq(Wall, Box, Empty, Robot).map(c => (c.repr, Seq(c))))\n  val ofChar2 = Map(\n    '#' -> Seq(Wall, Wall),\n    'O' -> Seq(LeftBox, RightBox),\n    '.' -> Seq(Empty, Empty),\n    '@' -> Seq(Robot, Empty))\n\n\nenum Direction:\n  case Up\n  case Down\n  case Left\n  case Right\n\n  def apply(row: Int, col: Int, n: Int = 1): (Int, Int) =\n    this match\n      case Up => (row - n, col)\n      case Down => (row + n, col)\n      case Left => (row, col - n)\n      case Right => (row, col + n)\n\nobject Direction:\n  val ofChar = Map('^' -> Up, 'v' -> Down, '>' -> Right, '<' -> Left)\n\n\nclass Warehouse(\n    val cells: ArraySeq[ArraySeq[WarehouseCell]],\n    val robotRow: Int,\n    val robotCol: Int):\n\n  def positionsToMove(posRow: Int, posCol: Int, d: Direction): Option[Seq[(Int, Int)]] =\n    val (nextRow, nextCol) = d(posRow, posCol)\n    cells.lift(nextRow).flatMap(_.lift(nextCol))\n      .flatMap((_, d) match\n        case (WarehouseCell.Empty, _) => Some(Nil)\n        case (WarehouseCell.Wall, _) => None\n        case (_, Direction.Left | Direction.Right) | (WarehouseCell.Box, _) =>\n          positionsToMove(nextRow, nextCol, d).map((nextRow, nextCol) +: _)\n        case (WarehouseCell.LeftBox, _) =>\n          positionsToMove(nextRow, nextCol, d).flatMap(posls =>\n            positionsToMove(nextRow, nextCol + 1, d).map(posrs =>\n              (nextRow, nextCol) +: (nextRow, nextCol + 1) +: (posls ++ posrs)))\n        case (WarehouseCell.RightBox, _) =>\n          positionsToMove(posRow, posCol - 1, d)\n        case (WarehouseCell.Robot, _) =>\n          throw AssertionError(\"should not reach robot in traversal\"))\n\n  def move(d: Direction): Warehouse =\n    positionsToMove(robotRow, robotCol, d) match\n      case None => this\n      case Some(positions) =>\n        val positionsAndRobot = ((robotRow, robotCol) +: positions)\n        val newCells = cells\n          .updated(positionsAndRobot.map((_, WarehouseCell.Empty)))\n          .updated(positionsAndRobot\n            .map((row, col) => (d(row, col), cells(row)(col))))\n        val (newRobotRow, newRobotCol) = d(robotRow, robotCol)\n        Warehouse(newCells, newRobotRow, newRobotCol)\n\n  def score: Int =\n    cells.iterator.zipWithIndex.flatMap((row, r) =>\n      row.iterator.zipWithIndex.map((cell, c) => cell match\n        case WarehouseCell.Box | WarehouseCell.LeftBox => 100*r + c\n        case _ => 0))\n      .sum\n\n\nobject Day15:\n  def parseMoves(input: Iterator[String]): Seq[Direction] =\n    // extra flatMap because the moves may be split across multiple lines\n    input.flatMap(_.map(Direction.ofChar)).toSeq\n\n  def parse(inputFile: String, cellMatcher: Char => Seq[WarehouseCell])\n      : (Warehouse, Seq[Direction]) =\n    val file = io.Source.fromFile(inputFile)\n    try\n      val input = file.getLines()\n      val cells = ArraySeq.from(input\n        // an empty line separates the grid from the moves\n        .takeWhile(!_.isEmpty)\n        .map(l => ArraySeq.from(l.toCharArray()).flatMap(cellMatcher)))\n      val robotRow = cells.indexWhere(_.contains(WarehouseCell.Robot))\n      val robotCol = cells(robotRow).indexOf(WarehouseCell.Robot)\n      (Warehouse(cells, robotRow, robotCol), parseMoves(input))\n    finally\n      file.close()\n\n  def part(cellMatcher: Char => Seq[WarehouseCell])(inputFile: String): Int =\n    val (warehouse, moves) = parse(inputFile, cellMatcher)\n    moves.foldLeft(warehouse)((wh, d) => wh.move(d)).score\n    \n  val part1 = part(WarehouseCell.ofChar1)\n  val part2 = part(WarehouseCell.ofChar2)\n")),(0,n.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/nikiforo/aoc24/blob/main/src/main/scala/io/github/nikiforo/aoc24/D15T2.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/nikiforo"},"Artem Nikiforov")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/aoc2024/blob/main/src/main/scala/Day15.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/merlinorg"},"merlinorg")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/aamiguet/advent-2024/blob/main/src/main/scala/ch/aamiguet/advent2024/Day15.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/aamiguet"},"Antoine Amiguet")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/AlexMckey/AoC2024_Scala/blob/master/src/year2024/day15.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/AlexMckey"},"Alex Mc'key")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck/advent2024/blob/main/day15/src/main/scala/Solution.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/rmarbeck"},"Rapha\xebl Marbeck")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://thedrawingcoder-gamer.github.io/aoc-writeups/2024/day15.html"},"Writeup")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/TheDrawingCoder-Gamer"},"Bulby")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/jportway/advent2024/blob/master/src/main/scala/Day15.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/jportway"},"Joshua Portway")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/Philippus/adventofcode/blob/main/src/main/scala/adventofcode2024/Day15.scala"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/philippus"},"Philippus Baalman")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2024/tree/main/src/main/scala/day15"},"Solution")," by ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,n.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}h.isMDXComponent=!0}}]);