"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7570],{3194:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>h});var a=n(7462),i=(n(7294),n(3905)),o=n(6340);const r={},s="Day 21: Keypad Conundrum",l={unversionedId:"2024/puzzles/day21",id:"2024/puzzles/day21",title:"Day 21: Keypad Conundrum",description:"by @mbovel",source:"@site/target/mdoc/2024/puzzles/day21.md",sourceDirName:"2024/puzzles",slug:"/2024/puzzles/day21",permalink:"/scala-advent-of-code/2024/puzzles/day21",draft:!1,editUrl:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2024/puzzles/day21.md",tags:[],version:"current",frontMatter:{},sidebar:"adventOfCodeSidebar",previous:{title:"Day 20: Race Condition",permalink:"/scala-advent-of-code/2024/puzzles/day20"},next:{title:"Day 22: Monkey Market",permalink:"/scala-advent-of-code/2024/puzzles/day22"}},p={},h=[{value:"Puzzle description",id:"puzzle-description",level:2},{value:"Data structures",id:"data-structures",level:2},{value:"Key insights",id:"key-insights",level:2},{value:"Interleaving directions doesn&#39;t help",id:"interleaving-directions-doesnt-help",level:3},{value:"Optimal directions order",id:"optimal-directions-order",level:3},{value:"Part 1",id:"part-1",level:2},{value:"Part 2",id:"part-2",level:2},{value:"Performance",id:"performance",level:2},{value:"JMH benchmark",id:"jmh-benchmark",level:3},{value:"Final code",id:"final-code",level:2},{value:"Run it in the browser",id:"run-it-in-the-browser",level:2},{value:"Part 1",id:"part-1-1",level:3},{value:"Part 2",id:"part-2-1",level:3},{value:"Solutions from the community",id:"solutions-from-the-community",level:2}],m={toc:h};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"day-21-keypad-conundrum"},"Day 21: Keypad Conundrum"),(0,i.kt)("p",null,"by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/mbovel"},"@mbovel")),(0,i.kt)("h2",{id:"puzzle-description"},"Puzzle description"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://adventofcode.com/2024/day/21"},"https://adventofcode.com/2024/day/21")),(0,i.kt)("h2",{id:"data-structures"},"Data structures"),(0,i.kt)("p",null,"We begin by defining the data structures used to represent the keypads and positions on the grid. We start with a ",(0,i.kt)("inlineCode",{parentName:"p"},"Pos")," case class for 2D coordinates. Then, we define two keypads\u2014",(0,i.kt)("inlineCode",{parentName:"p"},"numericKeypad")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"directionalKeypad"),"\u2014as ",(0,i.kt)("inlineCode",{parentName:"p"},"Map[Char, Pos]"),", with their corresponding sets of valid positions as ",(0,i.kt)("inlineCode",{parentName:"p"},"Set[Pos]"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"case class Pos(x: Int, y: Int):\n  def +(other: Pos) = Pos(x + other.x, y + other.y)\n  def -(other: Pos) = Pos(x - other.x, y - other.y)\n  def projX = Pos(x, 0)\n  def projY = Pos(0, y)\n\nval numericKeypad = Map(\n  '7' -> Pos(0, 0), '8' -> Pos(1, 0), '9' -> Pos(2, 0),\n  '4' -> Pos(0, 1), '5' -> Pos(1, 1), '6' -> Pos(2, 1),\n  '1' -> Pos(0, 2), '2' -> Pos(1, 2), '3' -> Pos(2, 2),\n                    '0' -> Pos(1, 3), 'A' -> Pos(2, 3),\n)\nval numericKeypadPositions = numericKeypad.values.toSet\n\nval directionalKeypad = Map(\n                    '^' -> Pos(1, 0), 'A' -> Pos(2, 0),\n  '<' -> Pos(0, 1), 'v' -> Pos(1, 1), '>' -> Pos(2, 1),\n)\nval directionalKeypadPositions = directionalKeypad.values.toSet\n")),(0,i.kt)("h2",{id:"key-insights"},"Key insights"),(0,i.kt)("h3",{id:"interleaving-directions-doesnt-help"},"Interleaving directions doesn't help"),(0,i.kt)("p",null,"Consider the numeric keypad. Suppose we want to go from ",(0,i.kt)("inlineCode",{parentName:"p"},"3")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"4"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"+---+---+---+\n| 7 | 8 | 9 |\n+---+---+---+\n|[4]| 5 | 6 |\n+---+---+---+\n| 1 | 2 |[3]|\n+---+---+---+\n    | 0 | A |\n    +---+---+\n")),(0,i.kt)("p",null,"There are three possible shortest paths:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"a) <<^A: 3 -> 2 -> 1 -> 4\nb) <^<A: 3 -> 2 -> 5 -> 4\nc) ^<<A: 3 -> 6 -> 5 -> 4\n")),(0,i.kt)("p",null,"A shortest path here is always a combination of moves in two directions: up (",(0,i.kt)("inlineCode",{parentName:"p"},"^"),") and left (",(0,i.kt)("inlineCode",{parentName:"p"},"<"),")."),(0,i.kt)("p",null,"Our first key insight is that ",(0,i.kt)("strong",{parentName:"p"},"interleaving moves in different directions never reduces the cost for the next robot"),". Interleaving forces the robot to travel more, rather than staying in the same position and repeatedly pressing ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),"."),(0,i.kt)("p",null,"To confirm, we can compute the shortest paths for the next robot in these examples using a ",(0,i.kt)("inlineCode",{parentName:"p"},"minPath")," function (defined later):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'minPath("<<^A")\n// res0: String = "v<<AA>^A>A"\nminPath("<<^A").length\n// res1: Int = 10\n\nminPath("<^<A")\n// res2: String = "v<<A>^Av<A>>^A"\nminPath("<^<A").length\n// res3: Int = 14\n\nminPath("^<<A")\n// res4: String = "<Av<AA>>^A"\nminPath("^<<A").length\n// res5: Int = 10\n')),(0,i.kt)("p",null,"As you can see, interleaving doesn't help. In fact, in this example, it makes the result worse: the paths for ",(0,i.kt)("inlineCode",{parentName:"p"},"a)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"c)")," both have length 10, while path ",(0,i.kt)("inlineCode",{parentName:"p"},"b)")," has length 14."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Because this article is typeset using ",(0,i.kt)("a",{parentName:"p",href:"https://scalameta.org/mdoc"},"mdoc"),", the code snippets above are actually executed. The comments are automatically added by mdoc based on runtime output. See ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/edit/website/docs/2024/puzzles/day21.md"},"the source")," for more details!")),(0,i.kt)("h3",{id:"optimal-directions-order"},"Optimal directions order"),(0,i.kt)("p",null,"Therefore, when computing directions between two keys, there are only two possibilities: move horizontally first or move vertically first."),(0,i.kt)("p",null,"Interestingly, from experiments, the chosen order only affects the second next robot in most cases. For instance, take ",(0,i.kt)("inlineCode",{parentName:"p"},'"v>A"')," and ",(0,i.kt)("inlineCode",{parentName:"p"},'">vA"'),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'minPath("v>A")\n// res6: String = "<vA>A^A"\nminPath(minPath("v>A"))\n// res7: String = "v<<A>A^>AvA^A<A>A"\nminPath(minPath("v>A")).length\n// res8: Int = 17\n\nminPath(">vA")\n// res9: String = "vA<A^>A"\nminPath(minPath(">vA"))\n// res10: String = "<vA^>Av<<A>>^A<Av>A^A"\nminPath(minPath(">vA")).length\n// res11: Int = 21\n')),(0,i.kt)("p",null,"Here, going vertically first (",(0,i.kt)("inlineCode",{parentName:"p"},"v>A"),") turns out to be optimal. However, there are also cases where horizontal-first is better:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'minPath("v<A")\n// res12: String = "<vA<A>>^A"\nminPath(minPath("v<A"))\n// res13: String = "v<<A>A^>Av<<A>>^AvAA<^A>A"\nminPath(minPath("v<A")).length\n// res14: Int = 25\n\nminPath("<vA")\n// res15: String = "v<<A>A^>A"\nminPath(minPath("<vA"))\n// res16: String = "<vA<AA>>^AvA^A<Av>A^A"\nminPath(minPath("<vA")).length\n// res17: Int = 21\n')),(0,i.kt)("p",null,"We can systematically check all combinations of up/down with left/right:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"for h <- List('>', '<') do\n  for v <- List('^', 'v') do\n    println(s\"$v$h: ${minPath(minPath(s\"$v$h\")).size}\")\n    println(s\"$h$v: ${minPath(minPath(s\"$h$v\")).size}\")\n// ^>: 15\n// >^: 15\n// v>: 13\n// >v: 14\n// ^<: 17\n// <^: 17\n// v<: 17\n// <v: 14\n")),(0,i.kt)("p",null,"Our second key insight is that ",(0,i.kt)("strong",{parentName:"p"},"the optimal direction order is consistent for each pair of directions"),", though there\u2019s no straightforward formal proof presented here. In practice, there\u2019s exactly one case (",(0,i.kt)("inlineCode",{parentName:"p"},"v>"),") that prefers vertical first. Everywhere else, horizontal-first either works better or doesn\u2019t matter.  "),(0,i.kt)("p",null,"There are also situations where one direction sequence would cross the gap\u2014which is not allowed\u2014so the order is effectively forced:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"In particular, if a robot arm is ever aimed at a gap where no button is present on the keypad, even for an instant, the robot will panic unrecoverably. So, don't do that. All robots will initially aim at the keypad's A key, wherever it is.")),(0,i.kt)("p",null,"For example, to go from ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),", the only valid sequence is ",(0,i.kt)("inlineCode",{parentName:"p"},"^<"),", since ",(0,i.kt)("inlineCode",{parentName:"p"},"<^")," would pass through a gap (",(0,i.kt)("inlineCode",{parentName:"p"},"X"),"):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"+---+---+---+\n| 7 | 8 | 9 |\n+---+---+---+\n| 4 | 5 | 6 |\n+---+---+---+\n|[1]| 2 |[3]|\n+---+---+---+\n  X |[0]| A |\n    +---+---+\n")),(0,i.kt)("h2",{id:"part-1"},"Part 1"),(0,i.kt)("p",null,"Using these insights, we define the ",(0,i.kt)("inlineCode",{parentName:"p"},"minPath")," function to compute the optimal path for a given ",(0,i.kt)("inlineCode",{parentName:"p"},"input"),", using the numeric keypad if ",(0,i.kt)("inlineCode",{parentName:"p"},"isNumeric")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", or the directional keypad otherwise. It relies on ",(0,i.kt)("inlineCode",{parentName:"p"},"minPathStep"),"."),(0,i.kt)("p",null,"Our two insights are captured by the ",(0,i.kt)("inlineCode",{parentName:"p"},"reverse")," condition inside ",(0,i.kt)("inlineCode",{parentName:"p"},"minPathStep"),": we switch to writing vertical moves first if horizontal-first would cross a gap, or if vertical-first is safe and the horizontal move is to the right."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def minPathStep(from: Pos, to: Pos, positions: Set[Pos]): String =\n  val shift = to - from\n  val h = (if shift.x > 0 then ">" else "<") * shift.x.abs\n  val v = (if shift.y > 0 then "v" else "^") * shift.y.abs\n  val reverse = !positions(from + shift.projX) || (positions(from + shift.projY) && shift.x > 0)\n  if reverse then v + h + \'A\' else h + v + \'A\'\n\ndef minPath(input: String, isNumeric: Boolean = false): String =\n  val keypad = if isNumeric then numericKeypad else directionalKeypad\n  val positions = if isNumeric then numericKeypadPositions else directionalKeypadPositions\n  (s"A$input").map(keypad).sliding(2).map(p => minPathStep(p(0), p(1), positions)).mkString\n\ndef part1(input: String): Long =\n  input\n    .linesIterator\n    .filter(_.nonEmpty)\n    .map: line => // 029A\n      val path1 = minPath(line, isNumeric = true) // <A^A^^>AvvvA\n      val path2 = minPath(path1) // v<<A>>^A<A>A<AAv>A^A<vAAA^>A\n      val path3 = minPath(path2) // <vA<AA>>^AvAA<^A>Av<<A>>^AvA^Av<<A>>^AA<vA>A^A<A>Av<<A>A^>AAA<Av>A^A\n      val num = line.init.toLong // 29\n      val len = path3.length() // 68\n      len * num // 211930\n    .sum\n')),(0,i.kt)("p",null,"The comments in ",(0,i.kt)("inlineCode",{parentName:"p"},"part1")," demonstrate intermediate results for the sample input ",(0,i.kt)("inlineCode",{parentName:"p"},"029A"),"."),(0,i.kt)("h2",{id:"part-2"},"Part 2"),(0,i.kt)("p",null,"Although the above approach works for three consecutive robots, it does not scale to 25 robots because path size grows exponentially. Instead, we refactor the code to compute only the cost of each path, not the path itself. This leads to two new functions, ",(0,i.kt)("inlineCode",{parentName:"p"},"minPathStepCost")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"minPathCost"),", which incorporate a ",(0,i.kt)("inlineCode",{parentName:"p"},"level")," parameter for the current robot (with 0 indicating the numeric keypad) and a ",(0,i.kt)("inlineCode",{parentName:"p"},"maxLevel")," parameter for the last robot. We also use ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Memoization"},"memoization")," to cache results for performance, since these functions are called repeatedly with the same arguments."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'val cache = collection.mutable.Map.empty[(Pos, Pos, Int, Int), Long]\ndef minPathStepCost(from: Pos, to: Pos, level: Int, maxLevel: Int): Long =\n  cache.getOrElseUpdate((from, to, level, maxLevel), {\n    val positions = if level == 0 then numericKeypadPositions else directionalKeypadPositions\n    val shift = to - from\n    val h = (if shift.x > 0 then ">" else "<") * shift.x.abs\n    val v = (if shift.y > 0 then "v" else "^") * shift.y.abs\n    val reverse = !positions(from + shift.projX) || (positions(from + shift.projY) && shift.x > 0)\n    val res = if reverse then v + h + \'A\' else h + v + \'A\'\n    if level == maxLevel then res.length() else minPathCost(res, level + 1, maxLevel)\n  })\n\ndef minPathCost(input: String, level: Int, maxLevel: Int): Long =\n  val keypad = if level == 0 then numericKeypad else directionalKeypad\n  (s"A$input").map(keypad).sliding(2).map(p => minPathStepCost(p(0), p(1), level, maxLevel)).sum\n\ndef part2(input: String): Long =\n  input\n    .linesIterator\n    .filter(_.nonEmpty)\n    .map(line => minPathCost(line, 0, 25) * line.init.toLong)\n    .sum\n')),(0,i.kt)("h2",{id:"performance"},"Performance"),(0,i.kt)("p",null,"On my example puzzle input, the solution completes in about 55 ms on the JVM and 3 ms on ",(0,i.kt)("a",{parentName:"p",href:"https://scala-native.org/en/stable/"},"Scala Native")," when measured naively and with no warm-up:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'@main def part2time: Unit =\n  val start = System.currentTimeMillis()\n  println(s"The solution is ${part2(loadInput())}")\n  val end = System.currentTimeMillis()\n  println(s"Execution time: ${end - start} ms")\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"\u279c  ~/scala-advent-of-code/solutions/2024 git:(4fc4c4251) \u2717 scala . -M day21.part2\nThe solution is 263492840501566\nExecution time: 55 ms\n\u279c  ~/scala-advent-of-code/solutions/2024 git:(4fc4c4251) \u2717 scala --native . -M day21.part2\nThe solution is 263492840501566\nExecution time: 3 ms\n")),(0,i.kt)("h3",{id:"jmh-benchmark"},"JMH benchmark"),(0,i.kt)("p",null,"The JVM time above is higher because we measured a cold runtime with no warm-up. To measure hot performance, we can use ",(0,i.kt)("a",{parentName:"p",href:"https://openjdk.java.net/projects/code-tools/jmh/"},"JMH")," as shown below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"// 2024/src/day21.bench.scala\n// Run with `scala 2024 --power --jmh`\npackage day21\n\nimport org.openjdk.jmh.annotations.{Benchmark, BenchmarkMode, Mode, OutputTimeUnit, Warmup}\nimport java.util.concurrent.TimeUnit\n\n@BenchmarkMode(Array(Mode.SingleShotTime))\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@Warmup(iterations = 50)\nclass Day21Bench:\n  @Benchmark def bench() =\n    cache.clear()\n    part2(loadInput())\n  @Benchmark def benchComputeOnly() =\n    cache.clear()\n    part2(Day21Bench.input)\n\nobject Day21Bench:\n  val input = day21.loadInput()\n")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"You can run this benchmark directly with Scala CLI\u2019s experimental ",(0,i.kt)("a",{parentName:"p",href:"https://scala-cli.virtuslab.org/docs/reference/cli-options/#--power"},(0,i.kt)("inlineCode",{parentName:"a"},"--power"))," and ",(0,i.kt)("a",{parentName:"p",href:"https://scala-cli.virtuslab.org/docs/reference/cli-options/#--jmh"},(0,i.kt)("inlineCode",{parentName:"a"},"--jmh"))," options (Scala CLI is the default scala runner since Scala 3.5.0, see the ",(0,i.kt)("a",{parentName:"p",href:"https://www.scala-lang.org/blog/2024/08/22/scala-3.5.0-released.html"},"announcement")," for more details). Another option is to use ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/sbt/sbt-jmh"},"sbt-jmh")," within an SBT project. ")),(0,i.kt)("p",null,"After 50 warm-up iterations, the runtime is about 1.5 ms including input loading, or 1.3 ms when only computing the result:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Benchmark                    Mode  Cnt  Score   Error  Units\nDay21Bench.bench               ss    5  1.548 \xb1 0.470  ms/op\nDay21Bench.benchComputeOnly    ss    5  1.268 \xb1 0.596  ms/op\n")),(0,i.kt)("p",null,"After 500 warm-up iterations, the timings drop to 0.3 ms and 0.2 ms, respectively:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Benchmark                    Mode  Cnt  Score   Error  Units\nDay21Bench.bench               ss    5  0.300 \xb1 0.052  ms/op\nDay21Bench.benchComputeOnly    ss    5  0.238 \xb1 0.006  ms/op\n")),(0,i.kt)("p",null,"And with 5000 warm-up iterations, we see similar results:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Benchmark                    Mode  Cnt  Score   Error  Units\nDay21Bench.bench               ss    5  0.273 \xb1 0.028  ms/op\nDay21Bench.benchComputeOnly    ss    5  0.239 \xb1 0.061  ms/op\n")),(0,i.kt)("p",null,"These results come from running five forks of five iterations each on a MacBook Pro (2019) with a 2.6 GHz 6-Core Intel Core i7 processor."),(0,i.kt)("h2",{id:"final-code"},"Final code"),(0,i.kt)("p",null,"See the complete code on ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/blob/main/2024/src/day21.scala"},"GitHub"),"."),(0,i.kt)("h2",{id:"run-it-in-the-browser"},"Run it in the browser"),(0,i.kt)("p",null,"Thanks to the ",(0,i.kt)("a",{parentName:"p",href:"https://www.scala-js.org/"},"Scala.js")," build, you can also experiment with this code directly in the browser."),(0,i.kt)("h3",{id:"part-1-1"},"Part 1"),(0,i.kt)(o.Z,{puzzle:"day21-part1",year:"2024",mdxType:"Solver"}),(0,i.kt)("h3",{id:"part-2-1"},"Part 2"),(0,i.kt)(o.Z,{puzzle:"day21-part2",year:"2024",mdxType:"Solver"}),(0,i.kt)("h2",{id:"solutions-from-the-community"},"Solutions from the community"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg/aoc2024/blob/main/src/main/scala/Day21.scala"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/merlinorg"},"merlinorg")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL/Advent-of-Code-2024/tree/main/src/main/scala/day21"},"Solution")," by ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/AvaPL"},"Pawe\u0142 Cembaluk"))),(0,i.kt)("p",null,"Share your solution to the Scala community by editing this page.\nYou can even write the whole article! ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala-advent-of-code/discussions/424"},"See here for the expected format")))}c.isMDXComponent=!0}}]);